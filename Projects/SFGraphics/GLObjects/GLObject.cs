using System;
using SFGraphics.GLObjects.GLObjectManagement;

namespace SFGraphics.GLObjects
{
    /// <summary>
    /// <see cref="GLObject"/> provides a simpler and less error prone
    /// way to deal with the state and data associated with OpenGL objects. 
    /// <para></para><para></para>
    /// Methods and constructors should only be called when a context is current.
    /// <see cref="Id"/> allows functionality not provided by the class. 
    /// This may break the functionality of existing methods.
    /// <para></para><para></para>
    /// This class provides reference counting for memory management. 
    /// Call <see cref="GLObjectManager.DeleteUnusedGLObjects"/> to delete 
    /// unused objects. 
    /// </summary>
    public abstract class GLObject
    {
        /// <summary>
        /// The available types of OpenGL objects.
        /// Enables <see cref="GLObjectManager"/> to call the appropriate delete function.
        /// </summary>
        public enum GLObjectType
        {
            /// <summary>
            /// <see cref="GLObjects.Framebuffer"/>
            /// </summary>
            Framebuffer,

            /// <summary>
            /// <see cref="GLObjects.Renderbuffer"/>
            /// </summary>
            Renderbuffer,

            /// <summary>
            /// <see cref="Textures.Texture"/>
            /// </summary>
            Texture,

            /// <summary>
            /// <see cref="Shaders.Shader"/>
            /// </summary>
            Program,

            /// <summary>
            /// <see cref="BufferObject"/>
            /// </summary>
            Buffer,

            /// <summary>
            /// <see cref="VertexArrayObject"/>
            /// </summary>
            VertexArray
        }

        /// <summary>
        /// The value generated by GL.GenTexture(), GL.GenProgram(), etc. 
        /// Do not use <see cref="GLObject.Id"/> after the container object is unreachable.
        /// </summary>
        public readonly int Id;

        /// <summary>
        /// 
        /// </summary>
        public abstract GLObjectType ObjectType { get; }

        /// <summary>
        /// Increments the reference count and initializes <see cref="Id"/>.
        /// </summary>
        public GLObject(int id)
        {
            // We need a constructor to set the readonly field and preserve polymorphic behavior.
            Id = id;
            ReferenceCounting.IncrementReference(GLObjectManager.referenceCountByGLObject, new Tuple<GLObjectType, int>(ObjectType, Id));
            System.Diagnostics.Debug.WriteLine($"Type { ObjectType }, ID: { Id } References: { GLObjectManager.referenceCountByGLObject[new Tuple<GLObjectType, int>(ObjectType, Id)] }");
        }

        /// <summary>
        /// Decrements the reference count for <see cref="Id"/>.
        /// The object can't be deleted here because finalizers are called from a separate thread.
        /// </summary>
        ~GLObject()
        {
            ReferenceCounting.DecrementReference(GLObjectManager.referenceCountByGLObject, new Tuple<GLObjectType, int>(ObjectType, Id));
            System.Diagnostics.Debug.WriteLine($"Type { ObjectType }, ID: { Id } References: { GLObjectManager.referenceCountByGLObject[new Tuple<GLObjectType, int>(ObjectType, Id)] }");
        }
    }
}
