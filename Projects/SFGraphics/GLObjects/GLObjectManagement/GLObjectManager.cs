using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using OpenTK.Graphics.OpenGL;
using SFGraphics.GLObjects;

namespace SFGraphics.GLObjects
{
    /// <summary>
    /// Manages reference counting and resource management for all GLObjects. 
    /// Each GLObject has an integer ID generated by OpenTK. When an object is created, the reference count for that ID is incremented.
    /// When the finalizer is called for an object, the reference count is decremented. 
    /// <para></para> <para></para>
    /// <see cref="GLObjectManager"/> will maintain reference counts for <see cref="Shaders.Shader"/> or any class inheriting from <see cref="Textures.Texture"/>,
    /// <see cref="BufferObject"/>, or <see cref="Framebuffer"/>.
    /// <para></para>
    /// Call <see cref="DeleteUnusedGLObjects"/> with a valid OpenTK context current to delete objects with no references.
    /// The reference count is managed automatically, so there is no need to call GL.DeleteTexture(int), for example.
    /// </summary>
    public static class GLObjectManager
    {
        // Use internal methods/variables so people can't mess this up.
        internal static ConcurrentDictionary<Tuple<GLObject.GLObjectType, int>, int> referenceCountByGLObject = 
            new ConcurrentDictionary<Tuple<GLObject.GLObjectType, int>, int>();

        /// <summary>
        /// The appropriate GL.Delete() function is called for all GLObjects if the <c>ID</c> has 0 references.
        /// This means GLObjects may not be cleaned up until long after the original object becomes unreachable.
        /// <para>
        /// Call <see cref="GC.WaitForPendingFinalizers"/> prior to <see cref="DeleteUnusedGLObjects"/> if more 
        /// immediate cleanup is desired.
        /// </para>
        /// </summary>
        public static void DeleteUnusedGLObjects()
        {
            DeleteUnusedObjects(referenceCountByGLObject);
        }

        private static void DeleteUnusedObjects(ConcurrentDictionary<Tuple<GLObject.GLObjectType, int>, int> referenceCountById)
        {
            HashSet<Tuple<GLObject.GLObjectType, int>> objectsNoReferences = ReferenceCounting.FindIdsWithNoReferences(referenceCountById);

            // Remove and delete associated data for Ids with no more references.
            foreach (var glObject in objectsNoReferences)
            {
                int value;
                if (referenceCountById.TryRemove(glObject, out value))
                {
                    DeleteIdBasedOnType(glObject);
                }
            }
        }

        private static void DeleteIdBasedOnType(Tuple<GLObject.GLObjectType, int> glObject)
        {
            switch (glObject.Item1)
            {
                default:
                    throw new NotImplementedException("Memory leaks :)");
                case GLObject.GLObjectType.Buffer:
                    GL.DeleteBuffer(glObject.Item2);
                    break;
                case GLObject.GLObjectType.Program:
                    GL.DeleteProgram(glObject.Item2);
                    break;
                case GLObject.GLObjectType.VertexArray:
                    GL.DeleteVertexArray(glObject.Item2);
                    break;
                case GLObject.GLObjectType.Framebuffer:
                    GL.DeleteFramebuffer(glObject.Item2);
                    break;
                case GLObject.GLObjectType.Texture:
                    GL.DeleteTexture(glObject.Item2);
                    break;
                case GLObject.GLObjectType.Renderbuffer:
                    GL.DeleteRenderbuffer(glObject.Item2);
                    break;
            }
        }
    }
}
