using System;
using System.Collections.Generic;
using System.Drawing;
using OpenTK;
using OpenTK.Graphics.OpenGL;
using System.Runtime.InteropServices;
using System.Drawing.Imaging;
using SFGraphics.GLObjects.Textures;

namespace SFGraphics.GLObjects
{
    /// <summary>
    /// Encapsulates an OpenGL framebuffer, including any attached color or depth attachments.
    /// </summary>
    public class Framebuffer : IGLObject
    {
        /// <summary>
        /// The value generated by GL.GenFramebuffer(). Do not attempt to bind <see cref="Id"/> when the object has become unreachable.
        /// </summary>
        public int Id { get; }

        /// <summary>
        /// The target which <see cref="Id"/> is bound when calling <see cref="Bind"/>.
        /// </summary>
        public FramebufferTarget FramebufferTarget { get; }

        /// <summary>
        /// 
        /// </summary>
        public PixelInternalFormat PixelInternalFormat { get; }

        /// <summary>
        /// All attached textures, renderbuffers, etc are resized when set. The framebuffer's contents will not be preserved when resizing.
        /// </summary>
        public int Width
        {
            get { return width; }
            set
            {
                width = value;
                Resize();
            }
        }
        private int width = 1;

        /// <summary>
        /// All attached textures, renderbuffers, etc are resized when set. The framebuffer's contents will not be preserved when resizing.
        /// </summary>
        public int Height
        {
            get { return height; }
            set
            {
                height = value;
                Resize();
            }
        }
        private int height = 1;

        /// <summary>
        /// All color attachment textures. This list may be empty if <c>0</c> is specified for the color attachment count.
        /// Attempting to modify the textures in this list may result in unexpected behavior.
        /// </summary>
        public List<Texture2D> ColorAttachments { get; }

        // TODO: Is this memory deallocated properly?
        private int rboDepth;

        /// <summary>
        /// Generates an empty framebuffer with no attachments bound to the specified target. 
        /// Binds the framebuffer.
        /// </summary>
        /// <param name="framebufferTarget">The target to which <see cref="Id"/> is bound</param>
        public Framebuffer(FramebufferTarget framebufferTarget)
        {
            Id = GL.GenFramebuffer();
            GLObjectManager.AddReference(GLObjectManager.referenceCountByFramebufferId, Id);
            FramebufferTarget = framebufferTarget;
            Bind();
        }

        /// <summary>
        /// Generates a framebuffer with a color attachment of the specified pixel format and dimensions. 
        /// A render buffer of the same dimensions as the color attachment is generated for the depth component.
        /// Binds the framebuffer.
        /// </summary>
        /// <param name="framebufferTarget">The target to which <see cref="Id"/> is bound</param>
        /// <param name="width">The width of attached textures or renderbuffers</param>
        /// <param name="height">The height of attached textures or renderbuffers</param>
        /// <param name="pixelInternalFormat">The internal format for all color attachments</param>
        /// <param name="colorAttachmentsCount">The number of color attachments to create. 
        /// Ex: <c>1</c> would only create ColorAttachment0.</param>
        /// <exception cref="ArgumentOutOfRangeException">The number of color attachments is negative.</exception>
        public Framebuffer(FramebufferTarget framebufferTarget, int width, int height, 
            PixelInternalFormat pixelInternalFormat = PixelInternalFormat.Rgba, int colorAttachmentsCount = 1) 
            : this(framebufferTarget)
        {
            if (colorAttachmentsCount < 0)
                throw new ArgumentOutOfRangeException("Color attachment count must be non negative.");

            Bind();
            PixelInternalFormat = pixelInternalFormat;
            this.width = width;
            this.height = height;

            ColorAttachments = CreateColorAttachments(width, height, colorAttachmentsCount);

            SetupRboDepth(width, height);
        }

        private List<Texture2D> CreateColorAttachments(int width, int height, int colorAttachmentsCount)
        {
            List<Texture2D> colorAttachments = new List<Texture2D>();
            List<DrawBuffersEnum> attachmentEnums = new List<DrawBuffersEnum>();
            for (int i = 0; i < colorAttachmentsCount; i++)
            {
                Texture2D colorAttachment = CreateColorAttachment(width, height, FramebufferAttachment.ColorAttachment0 + i);
                colorAttachments.Add(colorAttachment);
                attachmentEnums.Add(DrawBuffersEnum.ColorAttachment0 + i);
            }
            // Draw to all color attachments.
            GL.DrawBuffers(colorAttachmentsCount, attachmentEnums.ToArray());

            return colorAttachments;
        }

        /// <summary>
        /// Decrement the reference count for <see cref="Id"/>. The context probably isn't current, so the data is deleted later by <see cref="GLObjectManager"/>.
        /// </summary>
        ~Framebuffer()
        {
            // TODO: Does this delete all attachments?
            GLObjectManager.RemoveReference(GLObjectManager.referenceCountByFramebufferId, Id);
        }

        /// <summary>
        /// Gets the named framebuffer status for this framebuffer.
        /// </summary>
        /// <returns></returns>
        public String GetStatus()
        {
            // Check if any of the settings were incorrect when creating the fbo.
            return GL.CheckNamedFramebufferStatus(Id, FramebufferTarget).ToString();
        }

        private Texture2D CreateColorAttachment(int width, int height, FramebufferAttachment framebufferAttachment)
        {
            // Don't use mipmaps for color attachments.
            Texture2D texture = new Texture2D(width, height, PixelInternalFormat)
            {
                MinFilter = TextureMinFilter.Nearest,
                MagFilter = TextureMagFilter.Linear
            };

            GL.FramebufferTexture2D(FramebufferTarget, framebufferAttachment, TextureTarget.Texture2D, texture.Id, 0);
            return texture;
        }

        private void SetupRboDepth(int width, int height)
        {
            // Render buffer for the depth attachment, which is necessary for depth testing.
            GL.GenRenderbuffers(1, out rboDepth);
            GL.BindRenderbuffer(RenderbufferTarget.Renderbuffer, rboDepth);
            GL.RenderbufferStorage(RenderbufferTarget.Renderbuffer, RenderbufferStorage.DepthComponent, width, height);
            GL.FramebufferRenderbuffer(FramebufferTarget, FramebufferAttachment.DepthAttachment, RenderbufferTarget.Renderbuffer, rboDepth);
        }

        /// <summary>
        /// Reads the framebuffer's contents into a Bitmap using GL.ReadPixels. 
        /// This is intended for screenshots, so it only works properly for framebuffers of type 
        /// PixelFormat.Rgba.
        /// </summary>
        /// <param name="saveAlpha">The alpha channel is saved when true or set to 255 (white) when false</param>
        /// <returns></returns>
        public Bitmap ReadImagePixels(bool saveAlpha = false)
        {
            // Calculate the number of bytes needed.
            int pixelByteLength = width * height * sizeof(float);
            byte[] pixels = new byte[pixelByteLength];

            // Read the pixels from the framebuffer. PNG uses the BGRA format. 
            // This probably won't work for HDR textures.
            Bind();
            GL.ReadPixels(0, 0, width, height, OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, pixels);
            byte[] fixedPixels = CopyImagePixels(width, height, saveAlpha, pixelByteLength, pixels);

            // Format and save the data
            Bitmap bmp = new Bitmap(width, height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
            BitmapData bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, bmp.PixelFormat);
            Marshal.Copy(fixedPixels, 0, bmpData.Scan0, fixedPixels.Length);
            bmp.UnlockBits(bmpData);
            return bmp;
        }

        /// <summary>
        /// The origin (0,0) corresponds to the top left of the screen.
        /// The coordinates are based on the framebuffer's dimensions 
        /// and not the screen's dimensions.
        /// </summary>
        /// <param name="x">The horizontal pixel coordinate</param>
        /// <param name="y">The vertical pixel coordinate</param>
        /// <returns>A color with the RGBA values of the selected pixel</returns>
        public Color SamplePixelColor(int x, int y)
        {
            Bind();
            // Only RGBA is supported for now.
            byte[] rgba = new byte[4];
            GL.ReadPixels(x, y, 1, 1, OpenTK.Graphics.OpenGL.PixelFormat.Rgba, PixelType.UnsignedByte, rgba);
            return Color.FromArgb(rgba[3], rgba[0], rgba[1], rgba[2]);
        }

        private static byte[] CopyImagePixels(int width, int height, bool saveAlpha, int pixelByteLength, byte[] pixels)
        {
            // Flip data because glReadPixels reads it in from bottom row to top row
            byte[] fixedPixels = new byte[pixelByteLength];
            for (int h = 0; h < height; h++)
            {
                for (int w = 0; w < width; w++)
                {
                    // Remove alpha blending from the end image - we just want the post-render colors
                    if (!saveAlpha)
                        pixels[((w + h * width) * sizeof(float)) + 3] = 255;

                    // Copy a 4 byte pixel one at a time
                    Array.Copy(pixels, (w + h * width) * sizeof(float), fixedPixels, ((height - h - 1) * width + w) * sizeof(float), sizeof(float));
                }
            }

            return fixedPixels;
        }

        /// <summary>
        /// Binds the framebuffer to the target specified at creation.
        /// </summary>
        public void Bind()
        {
            GL.BindFramebuffer(FramebufferTarget, Id);
        }

        private void Resize()
        {
            Bind();
            
            // Resize all attachments.
            for (int i = 0; i < ColorAttachments.Count; i++)
            {
                ColorAttachments[i].Bind();
                GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat, width, height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Rgba, PixelType.Float, IntPtr.Zero);
                GL.FramebufferTexture2D(FramebufferTarget, FramebufferAttachment.ColorAttachment0 + i, TextureTarget.Texture2D, ColorAttachments[i].Id, 0);
            }

            // Render buffer for the depth attachment, which is necessary for depth testing.
            GL.BindRenderbuffer(RenderbufferTarget.Renderbuffer, rboDepth);
            GL.RenderbufferStorage(RenderbufferTarget.Renderbuffer, RenderbufferStorage.DepthComponent, width, height);
            GL.FramebufferRenderbuffer(FramebufferTarget, FramebufferAttachment.DepthAttachment, RenderbufferTarget.Renderbuffer, rboDepth);

            // Bind the default framebuffer again.
            GL.BindFramebuffer(FramebufferTarget.Framebuffer, 0);
        }
    }
}
